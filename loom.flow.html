<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script>
<!-- Google Analytics -->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
      '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-37511940-1']);
      _gaq.push(['_trackPageview']);
      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();
     </script>
<title>loom.flow documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Loom 0.5.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>loom</span></div></div></li><li class="depth-2 branch"><a href="loom.alg.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alg</span></div></a></li><li class="depth-2 branch"><a href="loom.alg-generic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alg-generic</span></div></a></li><li class="depth-2 branch"><a href="loom.attr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>attr</span></div></a></li><li class="depth-2 branch current"><a href="loom.flow.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>flow</span></div></a></li><li class="depth-2 branch"><a href="loom.gen.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gen</span></div></a></li><li class="depth-2 branch"><a href="loom.graph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph</span></div></a></li><li class="depth-2 branch"><a href="loom.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-2 branch"><a href="loom.label.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>label</span></div></a></li><li class="depth-2"><a href="loom.multigraph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>multigraph</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="loom.flow.html#var-augment-along-path"><div class="inner"><span>augment-along-path</span></div></a></li><li class="depth-1"><a href="loom.flow.html#var-bf-find-augmenting-path"><div class="inner"><span>bf-find-augmenting-path</span></div></a></li><li class="depth-1"><a href="loom.flow.html#var-edmonds-karp"><div class="inner"><span>edmonds-karp</span></div></a></li><li class="depth-1"><a href="loom.flow.html#var-flow-balance"><div class="inner"><span>flow-balance</span></div></a></li><li class="depth-1"><a href="loom.flow.html#var-is-admissible-flow.3F"><div class="inner"><span>is-admissible-flow?</span></div></a></li><li class="depth-1"><a href="loom.flow.html#var-min-weight-along-path"><div class="inner"><span>min-weight-along-path</span></div></a></li><li class="depth-1"><a href="loom.flow.html#var-residual-capacity"><div class="inner"><span>residual-capacity</span></div></a></li><li class="depth-1"><a href="loom.flow.html#var-satisfies-capacity-constraints.3F"><div class="inner"><span>satisfies-capacity-constraints?</span></div></a></li><li class="depth-1"><a href="loom.flow.html#var-satisfies-mass-balance.3F"><div class="inner"><span>satisfies-mass-balance?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">loom.flow</h2><div class="doc"><pre class="plaintext">Algorithms for solving network flow
</pre></div><div class="public anchor" id="var-augment-along-path"><h3>augment-along-path</h3><div class="usage"><code>(augment-along-path flow capacity path increase)</code></div><div class="doc"><pre class="plaintext">Given a flow represented as an adjacency map, returns an updated flow.
Capacity is a function of two vertices, path is a sequence of
nodes, and increase is the amount by which the flow should be
augmented on this path. If at any point the increase exceeds forward
capacity, the excess is pushed in the reverse direction.  An exception
is thrown if the augmentation is impossible given capacity constraints.</pre></div></div><div class="public anchor" id="var-bf-find-augmenting-path"><h3>bf-find-augmenting-path</h3><div class="usage"><code>(bf-find-augmenting-path successors predecessors capacity flow s t)</code></div><div class="doc"><pre class="plaintext">Finds a shortest path in the flow network along which there remains
residual capacity.  Successors is a function which, given a vertex,
returns the vertices connected by outgoing edges.  Predecessors,
similarly is a function to get vertices connected by incoming
edges.  Capacity is a function which takes two vertices and returns
the capacity between them.  Flow is an adjacency map which contains
the current value of network flow.  s is the source node, t the
sink.</pre></div></div><div class="public anchor" id="var-edmonds-karp"><h3>edmonds-karp</h3><div class="usage"><code>(edmonds-karp successors predecessors capacity source sink)</code><code>(edmonds-karp successors predecessors capacity source sink flow)</code></div><div class="doc"><pre class="plaintext">Computes the maximum flow on a network, using the edmonds-karp algorithm.
Successors is a function that returns the outgoing neighbor
vertices of a vertex.  Predecessors is a function that returns the
incoming neighbor vertices for a vertex.  Capacity is a function of
two vertices that returns the capacity on the edge between them.
Source and sink are the unique vertices which supply and consume
flow respectively.

Returns a vector [flow value], where flow is an adjacency map that
represents flows between vertices, and value is the quantity of
flow passing from source to sink.</pre></div></div><div class="public anchor" id="var-flow-balance"><h3>flow-balance</h3><div class="usage"><code>(flow-balance flow)</code></div><div class="doc"><pre class="plaintext">Given a flow, returns a map of {node (sum(in weight) - sum(out weight))}
</pre></div></div><div class="public anchor" id="var-is-admissible-flow.3F"><h3>is-admissible-flow?</h3><div class="usage"><code>(is-admissible-flow? flow capacity source sink)</code></div><div class="doc"><pre class="plaintext">Verifies that a flow satisfies capacity and mass balance
constraints.  Does verify that a flow is maximum.</pre></div></div><div class="public anchor" id="var-min-weight-along-path"><h3>min-weight-along-path</h3><div class="usage"><code>(min-weight-along-path path weight-fn)</code></div><div class="doc"><pre class="plaintext">Given a path, represented by a sequence of nodes, and
weight-function, computes the minimum of the edge weights along the
path.  If an edge on the path is missing, returns 0.</pre></div></div><div class="public anchor" id="var-residual-capacity"><h3>residual-capacity</h3><div class="usage"><code>(residual-capacity capacity flow v1 v2)</code></div><div class="doc"><pre class="plaintext">Computes the residual capacity between nodes v1 and v2.  Capacity
is a function that takes two nodes, and returns the capacity on the
edge between them, if any.  Flow is the adjacency map which
represents the current flow in the network.</pre></div></div><div class="public anchor" id="var-satisfies-capacity-constraints.3F"><h3>satisfies-capacity-constraints?</h3><div class="usage"><code>(satisfies-capacity-constraints? flow capacity)</code></div><div class="doc"><pre class="plaintext">Given a flow map, and a capacity function, verifies that the flow
on each edge is &lt;= capacity of that edge.</pre></div></div><div class="public anchor" id="var-satisfies-mass-balance.3F"><h3>satisfies-mass-balance?</h3><div class="usage"><code>(satisfies-mass-balance? flow source sink)</code></div><div class="doc"><pre class="plaintext">Given a flow, verifies whether at each node the sum of in edge
weights is equal to the sum of out edge weights, except at the
source and sink. The source should have positive net outflow, the
sink negative, and together they should balance.</pre></div></div></div></body></html>
