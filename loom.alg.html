<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>loom.alg documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Loom 0.4.2 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="loom.alg.html"><span>loom.alg</span></a></li><li><a href="loom.alg-generic.html"><span>loom.alg-generic</span></a></li><li><a href="loom.attr.html"><span>loom.attr</span></a></li><li><a href="loom.flow.html"><span>loom.flow</span></a></li><li><a href="loom.gen.html"><span>loom.gen</span></a></li><li><a href="loom.graph.html"><span>loom.graph</span></a></li><li><a href="loom.io.html"><span>loom.io</span></a></li><li><a href="loom.label.html"><span>loom.label</span></a></li><li><a href="loom.multigraph.html"><span>loom.multigraph</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="loom.alg.html#var-bellman-ford"><span>bellman-ford</span></a></li><li><a href="loom.alg.html#var-bf-path"><span>bf-path</span></a></li><li><a href="loom.alg.html#var-bf-path-bi"><span>bf-path-bi</span></a></li><li><a href="loom.alg.html#var-bf-span"><span>bf-span</span></a></li><li><a href="loom.alg.html#var-bf-traverse"><span>bf-traverse</span></a></li><li><a href="loom.alg.html#var-bipartite-color"><span>bipartite-color</span></a></li><li><a href="loom.alg.html#var-bipartite-sets"><span>bipartite-sets</span></a></li><li><a href="loom.alg.html#var-bipartite%3F"><span>bipartite?</span></a></li><li><a href="loom.alg.html#var-connect"><span>connect</span></a></li><li><a href="loom.alg.html#var-connected-components"><span>connected-components</span></a></li><li><a href="loom.alg.html#var-connected%3F"><span>connected?</span></a></li><li><a href="loom.alg.html#var-dag%3F"><span>dag?</span></a></li><li><a href="loom.alg.html#var-density"><span>density</span></a></li><li><a href="loom.alg.html#var-dijkstra-path"><span>dijkstra-path</span></a></li><li><a href="loom.alg.html#var-dijkstra-path-dist"><span>dijkstra-path-dist</span></a></li><li><a href="loom.alg.html#var-dijkstra-span"><span>dijkstra-span</span></a></li><li><a href="loom.alg.html#var-dijkstra-traverse"><span>dijkstra-traverse</span></a></li><li><a href="loom.alg.html#var-distinct-edges"><span>distinct-edges</span></a></li><li><a href="loom.alg.html#var-loners"><span>loners</span></a></li><li><a href="loom.alg.html#var-longest-shortest-path"><span>longest-shortest-path</span></a></li><li><a href="loom.alg.html#var-max-flow"><span>max-flow</span></a></li><li><a href="loom.alg.html#var-post-traverse"><span>post-traverse</span></a></li><li><a href="loom.alg.html#var-pre-span"><span>pre-span</span></a></li><li><a href="loom.alg.html#var-pre-traverse"><span>pre-traverse</span></a></li><li><a href="loom.alg.html#var-scc"><span>scc</span></a></li><li><a href="loom.alg.html#var-shortest-path"><span>shortest-path</span></a></li><li><a href="loom.alg.html#var-strongly-connected%3F"><span>strongly-connected?</span></a></li><li><a href="loom.alg.html#var-topsort"><span>topsort</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>loom.alg documentation</h2><pre class="doc">Graph algorithms. Any graph record/type that satisfies the
Graph, Digraph, or WeightedGraph protocols (as appropriate per algorithm)
can use these functions.</pre><div class="public" id="var-bellman-ford"><h3>bellman-ford</h3><div class="usage"><code>(bellman-ford g start)</code></div><pre class="doc">Given a weighted, directed graph G = (V, E) with source start,
the Bellman-Ford algorithm produces map of single source shortest paths and their costs
if no negative-weight cycle that is reachable from the source exits,
and false otherwise, indicating that no solution exists.</pre></div><div class="public" id="var-bf-path"><h3>bf-path</h3><div class="usage"><code>(bf-path g start end &amp; opts)</code></div><pre class="doc">Return a path from start to end with the fewest hops (i.e. irrespective
of edge weights)</pre></div><div class="public" id="var-bf-path-bi"><h3>bf-path-bi</h3><div class="usage"><code>(bf-path-bi g start end)</code></div><pre class="doc">Using a bidirectional breadth-first search, finds a path from start to
end with the fewest hops (i.e. irrespective of edge weights). Can be much
faster than a unidirectional search on certain types of graphs</pre></div><div class="public" id="var-bf-span"><h3>bf-span</h3><div class="usage"><code>(bf-span g)</code><code>(bf-span g start)</code></div><pre class="doc">Return a breadth-first spanning tree of the form {node [successors]}
</pre></div><div class="public" id="var-bf-traverse"><h3>bf-traverse</h3><div class="usage"><code>(bf-traverse g)</code><code>(bf-traverse g start)</code><code>(bf-traverse g start &amp; opts)</code></div><pre class="doc">Traverses graph g breadth-first from start. When option :f is provided,
returns a lazy seq of (f node predecessor-map depth) for each node traversed.
Otherwise, returns a lazy seq of the nodes. When option :when is provided,
filters successors with (f neighbor predecessor depth).</pre></div><div class="public" id="var-bipartite-color"><h3>bipartite-color</h3><div class="usage"><code>(bipartite-color g)</code></div><pre class="doc">Attempt a two-coloring of graph g. When successful, returns a map of
nodes to colors (1 or 0). Otherwise, returns nil.</pre></div><div class="public" id="var-bipartite-sets"><h3>bipartite-sets</h3><div class="usage"><code>(bipartite-sets g)</code></div><pre class="doc">Return two sets of nodes, one for each color of the bipartite coloring,
or nil if g is not bipartite</pre></div><div class="public" id="var-bipartite%3F"><h3>bipartite?</h3><div class="usage"><code>(bipartite? g)</code></div><pre class="doc">Return true if g is bipartite
</pre></div><div class="public" id="var-connect"><h3>connect</h3><div class="usage"><code>(connect g)</code></div><pre class="doc">Return graph g with all connected components connected to each other
</pre></div><div class="public" id="var-connected-components"><h3>connected-components</h3><div class="usage"><code>(connected-components g)</code></div><pre class="doc">Return the connected components of graph g as a vector of vectors. If g
is directed, returns the weakly-connected components.</pre></div><div class="public" id="var-connected%3F"><h3>connected?</h3><div class="usage"><code>(connected? g)</code></div><pre class="doc">Returns true if g is connected
</pre></div><div class="public" id="var-dag%3F"><h3>dag?</h3><div class="usage"><code>(dag? g)</code></div><pre class="doc">Return true if g is a directed acyclic graph
</pre></div><div class="public" id="var-density"><h3>density</h3><div class="usage"><code>(density g &amp; {:keys [loops], :or {loops false}})</code></div><pre class="doc">Return the density of graph g
</pre></div><div class="public" id="var-dijkstra-path"><h3>dijkstra-path</h3><div class="usage"><code>(dijkstra-path g start end)</code></div><pre class="doc">Finds the shortest path from start to end
</pre></div><div class="public" id="var-dijkstra-path-dist"><h3>dijkstra-path-dist</h3><div class="usage"><code>(dijkstra-path-dist g start end)</code></div><pre class="doc">Finds the shortest path from start to end. Returns a vector:
[path distance]</pre></div><div class="public" id="var-dijkstra-span"><h3>dijkstra-span</h3><div class="usage"><code>(dijkstra-span g)</code><code>(dijkstra-span g start)</code></div><pre class="doc">Finds all shortest distances from start. Returns a map in the format
{node {successor distance}}</pre></div><div class="public" id="var-dijkstra-traverse"><h3>dijkstra-traverse</h3><div class="usage"><code>(dijkstra-traverse g)</code><code>(dijkstra-traverse g start)</code><code>(dijkstra-traverse g start f)</code></div><pre class="doc">Returns a lazy-seq of [current-node state] where state is a map in the
format {node [distance predecessor]}. When f is provided, returns
a lazy-seq of (f node state) for each node</pre></div><div class="public" id="var-distinct-edges"><h3>distinct-edges</h3><div class="usage"><code>(distinct-edges g)</code></div><pre class="doc">Distinct edges of g. Only useful for undirected graphs
</pre></div><div class="public" id="var-loners"><h3>loners</h3><div class="usage"><code>(loners g)</code></div><pre class="doc">Return nodes with no connections to other nodes (i.e., isolated nodes)
</pre></div><div class="public" id="var-longest-shortest-path"><h3>longest-shortest-path</h3><div class="usage"><code>(longest-shortest-path g start)</code></div><pre class="doc">Finds the longest shortest path beginning at start, using Dijkstra's
algorithm if the graph is weighted, breadth-first search otherwise.</pre></div><div class="public" id="var-max-flow"><h3>max-flow</h3><div class="usage"><code>(max-flow g source sink &amp; {:keys [method], :or {method :edmonds-karp}})</code></div><pre class="doc">Returns [flow-map flow-value], where flow-map is a weighted adjacency map
representing the maximum flow.  The argument should be a weighted digraph,
where the edge weights are flow capacities.  Source and sink are the vertices
representing the flow source and sink vertices.  Optionally, pass in
  :method :algorithm to use.  Currently, the only option is :edmonds-karp .</pre></div><div class="public" id="var-post-traverse"><h3>post-traverse</h3><div class="usage"><code>(post-traverse g)</code><code>(post-traverse g start &amp; opts)</code></div><pre class="doc">Traverses graph g depth-first, post-order from start. Returns a
vector of the nodes.</pre></div><div class="public" id="var-pre-span"><h3>pre-span</h3><div class="usage"><code>(pre-span g)</code><code>(pre-span g start)</code></div><pre class="doc">Return a depth-first spanning tree of the form {node [successors]}
</pre></div><div class="public" id="var-pre-traverse"><h3>pre-traverse</h3><div class="usage"><code>(pre-traverse g)</code><code>(pre-traverse g start)</code></div><pre class="doc">Traverses graph g depth-first from start. Returns a lazy seq of nodes.
When no starting node is provided, traverses the entire graph, connected
or not.</pre></div><div class="public" id="var-scc"><h3>scc</h3><div class="usage"><code>(scc g)</code></div><pre class="doc">Return the strongly-connected components of directed graph g as a vector of
vectors. Uses Kosaraju's algorithm.</pre></div><div class="public" id="var-shortest-path"><h3>shortest-path</h3><div class="usage"><code>(shortest-path g start end)</code></div><pre class="doc">Finds the shortest path from start to end in graph g, using Dijkstra's
algorithm if the graph is weighted, breadth-first search otherwise.</pre></div><div class="public" id="var-strongly-connected%3F"><h3>strongly-connected?</h3><div class="usage"><code>(strongly-connected? g)</code></div><pre class="doc"></pre></div><div class="public" id="var-topsort"><h3>topsort</h3><div class="usage"><code>(topsort g)</code><code>(topsort g start)</code></div><pre class="doc">Topological sort of a directed acyclic graph (DAG). Returns nil if
g contains any cycles.</pre></div></div></body></html>